Class {
	#name : #GLMTreeMorphicTest,
	#superclass : #GLMMorphicTest,
	#category : #'Glamour-Tests-Morphic'
}

{ #category : #tests }
GLMTreeMorphicTest >> testChildrenBlock [
	| browser check |
	browser := GLMFinder new.
	check := false.
	browser tree
		children: [ :each | 
			check := true.
			#() ].
	window := browser openOn: ($a to: $d).
	World doOneCycle.
	self repeatAssert: [ check ] equals: true
]

{ #category : #tests }
GLMTreeMorphicTest >> testChildrenBlockTakesEntity [
	| browser receivedEntity |
	browser := GLMFinder new.
	receivedEntity := nil.
	browser tree
		children: [:each :entity | receivedEntity := entity. #()].
	window := browser openOn: ($a to: $d).
	World doOneCycle.
	self repeatAssert: [receivedEntity] equals: ($a to: $d).

]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeAllowDeseletion [
	| browser treeNodeMorph |	
	browser := GLMFinder new.
	browser list allowDeselection.
	window := browser openOn: ($a to: $d).
	treeNodeMorph := self treeRoots first.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self assert: (browser panes first port: #selection) value isNil
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeDefaultAllowDeseletion [
	| browser treeNodeMorph |
	browser := GLMFinder new.
	browser tree.
	window := browser openOn: ($a to: $d).
	treeNodeMorph := self treeRoots first.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self assert: (browser panes first port: #selection) value = $a.
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeMultipleSelection [
	| browser treeNodeMorph lastTreeNodeMorph |
	browser := GLMFinder new.
	browser tree beMultiple.
	window := browser openOn: ($a to: $d).
	treeNodeMorph := self treeRoots first.
	lastTreeNodeMorph := self treeRoots last.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self send: self tree mouseUpWithShift: true onItem: lastTreeNodeMorph.
	self assert: (browser panes first port: #selection) value notNil.
	self assert: (browser panes first port: #selection) value asSet equals: ($a to: $d) asSet
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeMultipleSelectionWithCancellation [
	| browser treeNodeMorph lastTreeNodeMorph |
	browser := GLMFinder new.
	browser tree beMultiple allowDeselection.
	window := browser openOn: ($a to: $d).
	treeNodeMorph := self treeRoots first.
	lastTreeNodeMorph := self treeRoots last.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self send: self tree mouseUpWithShift: true onItem: lastTreeNodeMorph.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self assert: (browser panes first port: #selection) value isNil
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeSelection [
	| browser treeNodeMorph |
	browser := GLMFinder new.
	browser tree.
	window := browser openOn: ($a to: $d).
	treeNodeMorph := self treeRoots first.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self assert: (browser panes first port: #selection) value = $a
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeSelectionCancellation [
	| browser treeNodeMorph |
	browser := GLMFinder new.
	browser tree allowDeselection.
	window := browser openOn: ($a to: $d).
	treeNodeMorph := self treeRoots first.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self send: self tree mouseUpOnItem: treeNodeMorph.
	self assert: (browser panes first port: #selection) value isNil
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeWithDisplay [
	| browser treeCollection |
	treeCollection := { #root1->{#child1->{} . #child2->{}} . #root2 ->{} }.
	browser := GLMTabulator new.
	browser column: #one.
	browser showOn: #one; using: [
		browser tree
			display: [:each | each value ];
			children: [:x | x value ] ].
	window := browser openOn: #something -> treeCollection.
	self assert: browser panes first presentations first displayValue == treeCollection
]

{ #category : #tests }
GLMTreeMorphicTest >> testTreeWithTags [
	"Creates a tree and tag some nodes. Then click on a tag and see if the unmatched nodes disappear"

	| browser model oddNode lineWithNumber3 someNode secondSome |
	model := Dictionary new.
	model at: #some put: #(1 2 3 4).
	model at: #even put: #(2 6 8).
	model at: #odd put: #(3 7 9).
	browser := GLMTabulator new.
	browser column: #one.
	(browser transmit)
		to: #one;
		andShow: [ :a | 
					(browser tree)
						display: [ model keys ];
						children: [ :key | 
									key isNumber
										ifFalse: [ model at: key ] ];
						tags: [ :item | 
									item isNumber
										ifTrue: [ 
											item even
												ifTrue: [ #('even') ]
												ifFalse: [ #('odd') ] ]
										ifFalse: [ #() ] ] ].
	window := browser openOn: model.
	World doOneCycle.
	oddNode := self treeRoots second.	
	
	oddNode toggleExpandedState. "Simulate a click on the node's arrow to expand the node and make sub nodes visible"

	World doOneCycle.
	lineWithNumber3 := self treeRoots third.
	(self find: SimpleButtonMorph in: lineWithNumber3) doButtonAction. "Simulate a click on the 'odd' tag to make even numbers disappear"
	
	World doOneCycle.
	someNode := self treeRoots first.
	someNode toggleExpandedState.
	World doOneCycle.
	secondSome := self find: TextMorph in: self treeRoots third.
	self assert: secondSome text asString equals: '3'
]

{ #category : #private }
GLMTreeMorphicTest >> tree [
	^ self find: LazyMorphTreeMorph in: window
]

{ #category : #private }
GLMTreeMorphicTest >> treeRoots [
	"Returns the roots of the tree included in the current window. It looks like morphic creates new collections when the tree is refreshed which means different calls to this method may return different objects."
	^ self tree scroller submorphs
]
